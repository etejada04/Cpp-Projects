#ifndef __PROGTEST__#include <cstdio>#include <cstdlib>#include <cstdint>#include <cstring>#include <cassert>#include <cmath>#include <cctype>#include <climits>#include <iostream>#include <iomanip>#include <fstream>#include <sstream>#include <vector>#include <map>#include <set>#include <unordered_map>#include <unordered_set>#include <list>#include <algorithm>#include <functional>#include <memory>using namespace std;const uint16_t ENDIAN_LITTLE = 0x4949;const uint16_t ENDIAN_BIG    = 0x4d4d;#endif /* __PROGTEST__ */int getInter (int number){    int res = 0;    switch ( (number>>5)&0x07){        case 0x00:            res = 1; //Interleave of 1            break;        case 0x01:            res = 2; //Interleave of 2            break;        case 0x02:            res = 4; //Interleave of 4            break;        case 0x03:            res = 8; //Interleave of 8            break;        case 0x04:            res = 16; //Interleave of 16            break;        case 0x05:            res = 32; //Interleave of 32            break;        case 0x06:            res = 64; //Interleave of 64            break;        default:            res = 0; //Invalid combination            break;    }    return res;}int BPC (int number){    int res = 0;    switch ( (number>>2)&0x07){        case 0x00:            res = 1; //1 bit per channel            break;        case 0x03:            res = 8; //8 bits per channel            break;        case 0x04:            res = 16; //16 bits per channel            break;        default:            res = 0; //Invalid combination            break;    }    return res;}int channelNum (int number){    int res = 0;    switch (number&0x03){        case 0x00:            res = 1; //Black and with -> 1 channel            break;        case 0x02:            res = 3; //3 channels = RGB            break;        case 0x03:            res = 4; //4 channels = RGBA            break;        default:            res = 0; //Invalid combination            break;    }    return res;}uint16_t getPF(uint8_t n1, uint8_t n2, uint16_t byteOrder) {    uint16_t n;    if (byteOrder == LITTLE_ENDIAN) {        n = ((uint16_t) n1 << 8) | n2;    } else {        n = ((uint16_t) n2 << 8) | n1;    }    return n;}int getEndian(uint8_t n1, uint8_t n2){    uint16_t n;    if(n1 != n2){        n = 0;    }else{        n = ((uint16_t) n1 << 8)|n2;    }    return n;}int getDimension(uint8_t n1, uint8_t n2, uint16_t byteOrder){    uint16_t n;    if(byteOrder == LITTLE_ENDIAN){        n = ((uint16_t) n1 << 8)|n2;    }else{        n = ((uint16_t) n2 << 8)|n1;    }    return n;}uint8_t updateEndian(uint8_t num, uint16_t byteOrder){    num = (uint8_t) (num>>8);    if(byteOrder == ENDIAN_BIG)        num = (uint8_t) (num^77);    else if(byteOrder == ENDIAN_LITTLE)        num = (uint8_t) (num^73);    return num;}uint8_t updateInter(uint8_t num, int inter) {    num =  (uint8_t) (num<<3);    num =  (uint8_t) (num>>3);    switch (inter){        case 1:            num = (uint8_t) (num^0);            break;        case 2:            num = (uint8_t) (num^32);            break;        case 4:            num = (uint8_t) (num^64);            break;        case 8:            num = (uint8_t) (num^96);            break;        case 16:            num = (uint8_t) (num^128);            break;        case 32:            num = (uint8_t) (num^160);            break;        case 64:            num = (uint8_t) (num^192);            break;        default:            break;    }    return num;}vector<uint8_t > insertHeader (vector <uint8_t> vec){    vector <uint8_t > res (vec.size());    for (int i = 0; i < 8; ++i) {        res[i] = vec[i];    }    return res;}vector<uint8_t> convertUninter(vector<uint8_t > vec, int w, int h,int interleave, int pixsize, int inend, int outend){    int m = 0, vec_pos = 0, tmp_pos = 0;    vector <uint8_t > tmp = insertHeader(vec);    if(inend == ENDIAN_BIG && outend == ENDIAN_BIG)        tmp[7]=updateInter(tmp[7],interleave);    else if(inend == ENDIAN_LITTLE && outend == ENDIAN_BIG)        tmp[7]=updateInter(tmp[7],interleave);    else        tmp[6]=updateInter(tmp[6],interleave);    for (int k = interleave; k > 0  ; k/=2) {        for (int i = 0; i < h; i+=k) {            for (int j = 0; j < w; j+=k) {                if( !(i%(k*2)) && !(j%(k*2)) && k != interleave){                    continue;                }                vec_pos = 8+(i*w+j)*pixsize;                tmp_pos = 8+(m)*pixsize;                for (int l = 0; l < pixsize; ++l) {                    tmp[vec_pos+l] = vec[tmp_pos+l];                }                m++;            }        }    }    return tmp;}vector<uint8_t> convertInter(vector<uint8_t > vec, int w, int h,int interleave, int pixsize, int inend, int outend){    int m = 0, vec_pos = 0, tmp_pos = 0;    vector <uint8_t > tmp = insertHeader(vec);    if(inend == ENDIAN_BIG && outend == ENDIAN_BIG)        tmp[7]=updateInter(tmp[7],interleave);    else if(inend == ENDIAN_LITTLE && outend == ENDIAN_BIG)        tmp[7]=updateInter(tmp[7],interleave);    else        tmp[6]=updateInter(tmp[6],interleave);    for (int k = interleave; k > 0  ; k/=2) {        for (int i = 0; i < h; i+=k) {            for (int j = 0; j < w; j+=k) {                if( !(i%(k*2)) && !(j%(k*2)) && k != interleave){                    continue;                }                vec_pos = 8+(i*w+j)*pixsize;                tmp_pos = 8+(m)*pixsize;                for (int l = 0; l < pixsize; ++l) {                    tmp[tmp_pos+l] = vec[vec_pos+l];                }                m++;            }        }    }    return tmp;}vector<uint8_t> swapEndian(vector<uint8_t> vec){    vector<uint8_t> tmp (vec.size());    for (int i = 0; i < (int)vec.size(); i+=2) {        tmp[i]=vec[i];        vec[i] = vec[i+1];        vec[i+1] = tmp[i];    }    return vec;}bool writeFile(const char * dst, const vector<uint8_t>& vec) {  // Open the file in binary mode  ofstream file(dst, ios::out | ios::binary);  // Check if the file exists  if (!file.is_open())  {    //cout << "Problem with opening the file '" << dst << "'" << endl;    return false;  }    file.write(reinterpret_cast<const char*>(vec.data()), vec.size());  if (!file.good())  {    //cout << "An error has occurred" << endl;    return false;  }  return true;}bool validInput (int interleave, uint16_t byteOrder){    return (interleave == 1 || interleave == 2 || interleave == 4 || interleave == 8 || interleave == 16 || interleave == 32 || interleave == 64) && (byteOrder == ENDIAN_BIG || byteOrder == ENDIAN_LITTLE );}vector<uint8_t> openFile(const char *src) {    ifstream file(src, ios::in | ios::binary);    if (!file.is_open())    {        //cout << "Problem with opening the file -> '" << src << "'" << endl;        return vector<uint8_t>();    }    file.seekg(0, file.end);    size_t fileSize = (size_t) file.tellg();    file.seekg(0, file.beg);    vector<uint8_t> vec(fileSize);    file.read(reinterpret_cast<char *>(vec.data()), fileSize);    file.close();    return vec;}bool recodeImage ( const char  * srcFileName,                   const char  * dstFileName,                   int           interleave,                   uint16_t      byteOrder ){    vector<uint8_t > in, tmp;    int endian = 0, height = 0, width = 0, pixelf = 0, channels = 0, bpc = 0, inter = 0, pixsize = 0;    in = openFile(srcFileName);    if(in == vector<uint8_t>() || in.size() < 8){        return false;    } else {        endian = getEndian(in[0], in[1]);        if(endian == ENDIAN_BIG){            width = getDimension(in[3], in[2], byteOrder);            height = getDimension(in[5], in[4], byteOrder);            pixelf = getPF(in[7], in[6], byteOrder);            channels = channelNum(pixelf);            bpc = BPC(pixelf);            inter = getInter(pixelf);            pixsize = (bpc*channels)/8;        } else if(endian == ENDIAN_LITTLE) {            width = getDimension(in[2], in[3], byteOrder);            height = getDimension(in[4], in[5], byteOrder);            pixelf = getPF(in[6], in[7], byteOrder);            channels = channelNum(pixelf);            bpc = BPC(pixelf);            inter = getInter(pixelf);            pixsize = (bpc*channels)/8;        }        if(!validInput(interleave, byteOrder) || !writeFile(dstFileName,in) || (channels * width * height * bpc) / 8 != (int)in.size() - 8 || !validInput(inter, (uint16_t)endian) || !width || !height || !channels || !bpc || !inter){            return false;        }        if( byteOrder == ENDIAN_BIG && endian==ENDIAN_LITTLE){            in = swapEndian(in);            in[0] = updateEndian(in[0], byteOrder);            in[1] = updateEndian(in[1], byteOrder);        } else if(byteOrder == ENDIAN_LITTLE && endian==ENDIAN_BIG){            in = swapEndian(in);            in[0] = updateEndian(in[0], byteOrder);            in[1] = updateEndian(in[1], byteOrder);        }        if (inter == interleave && inter == 1){            writeFile(dstFileName, in);        } else if (inter != 1){            tmp = convertUninter(in, width, height, inter, pixsize, endian, byteOrder); //Uninterleave            in = convertInter(tmp, width, height, interleave, pixsize, endian, byteOrder); //Interleave            writeFile(dstFileName, in);        } else {            in = convertInter(in, width, height, interleave, pixsize, endian, byteOrder);            writeFile(dstFileName, in);        }    }    return true;}#ifndef __PROGTEST__bool identicalFiles ( const char * fileName1,                      const char * fileName2 ){    vector<uint8_t> f1,f2;    long int size = 0;    bool flag = 0;    f1 = openFile(fileName1);    f2 = openFile(fileName2);    if(f1 == vector<uint8_t>() || f2 == vector<uint8_t>()){        return false;    } else {        size = (f1.size()+f2.size())/ 2;        for (int i = 0; i < size; ++i) {            if (f1[i] == f2[i]){                flag = true;            } else {                flag = false;                break;            }        }    }    return flag && f1.size()==f2.size();}int main ( void ){   assert ( recodeImage ( "input_00.img", "output_00.img", 1, ENDIAN_LITTLE )             && identicalFiles ( "output_00.img", "ref_00.img" ) );    assert ( recodeImage ( "input_01.img", "output_01.img", 8, ENDIAN_LITTLE )             && identicalFiles ( "output_01.img", "ref_01.img" ) );    assert ( recodeImage ( "input_02.img", "output_02.img", 8, ENDIAN_LITTLE )             && identicalFiles ( "output_02.img", "ref_02.img" ) );    assert ( recodeImage ( "input_03.img", "output_03.img", 2, ENDIAN_LITTLE )             && identicalFiles ( "output_03.img", "ref_03.img" ) );    assert ( recodeImage ( "input_04.img", "output_04.img", 1, ENDIAN_LITTLE )             && identicalFiles ( "output_04.img", "ref_04.img" ) );    assert ( recodeImage ( "input_05.img", "output_05.img", 1, ENDIAN_LITTLE )             && identicalFiles ( "output_05.img", "ref_05.img" ) );    assert ( recodeImage ( "input_06.img", "output_06.img", 8, ENDIAN_LITTLE )             && identicalFiles ( "output_06.img", "ref_06.img" ) );    assert ( recodeImage ( "input_07.img", "output_07.img", 4, ENDIAN_LITTLE )             && identicalFiles ( "output_07.img", "ref_07.img" ) );    assert ( recodeImage ( "input_08.img", "output_08.img", 8, ENDIAN_LITTLE )             && identicalFiles ( "output_08.img", "ref_08.img" ) );    assert ( !recodeImage ( "input_09.img", "output_09.img", 1, ENDIAN_LITTLE ) );    assert (  !recodeImage ( "input_10.img", "output_10.img", 5, ENDIAN_LITTLE ) ); assert ( recodeImage ( "extra_input_00.img", "extra_out_00.img", 8, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_00.img", "extra_ref_00.img" ) );  assert ( recodeImage ( "extra_input_01.img", "extra_out_01.img", 4, ENDIAN_BIG )           && identicalFiles ( "extra_out_01.img", "extra_ref_01.img" ) );  assert ( recodeImage ( "extra_input_02.img", "extra_out_02.img", 16, ENDIAN_BIG )           && identicalFiles ( "extra_out_02.img", "extra_ref_02.img" ) );  assert ( recodeImage ( "extra_input_03.img", "extra_out_03.img", 1, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_03.img", "extra_ref_03.img" ) );  assert ( recodeImage ( "extra_input_04.img", "extra_out_04.img", 8, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_04.img", "extra_ref_04.img" ) );  assert ( recodeImage ( "extra_input_05.img", "extra_out_05.img", 4, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_05.img", "extra_ref_05.img" ) );  assert ( recodeImage ( "extra_input_06.img", "extra_out_06.img", 16, ENDIAN_BIG )           && identicalFiles ( "extra_out_06.img", "extra_ref_06.img" ) );  assert ( recodeImage ( "extra_input_07.img", "extra_out_07.img", 1, ENDIAN_BIG )           && identicalFiles ( "extra_out_07.img", "extra_ref_07.img" ) );  assert ( recodeImage ( "extra_input_08.img", "extra_out_08.img", 8, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_08.img", "extra_ref_08.img" ) );  assert ( recodeImage ( "extra_input_09.img", "extra_out_09.img", 4, ENDIAN_LITTLE )           && identicalFiles ( "extra_out_09.img", "extra_ref_09.img" ) );  assert ( recodeImage ( "extra_input_10.img", "extra_out_10.img", 16, ENDIAN_BIG )           && identicalFiles ( "extra_out_10.img", "extra_ref_10.img" ) );  assert ( recodeImage ( "extra_input_11.img", "extra_out_11.img", 1, ENDIAN_BIG )           && identicalFiles ( "extra_out_11.img", "extra_ref_11.img" ) );  return 0;}#endif /* __PROGTEST__ */